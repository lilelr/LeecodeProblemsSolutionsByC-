1 直接用数组从0开始的下标思考问题
2 自己想的比看过往代码写得还快
3 考虑边界的问题

4 while 结合 cnt,cnt 从0 开始
  int cnt = 0;
        while (n) {
            n = (n & (n - 1));
            cnt++;
        }

5  int pre = ex>>1; 1个数除以2 乘以2， <<2

6 是不是 偶数
 if(ex & 0x1 ==奇数){
            res *= base;
        }

7 递归函数写法 写出递归式 fun(3,7) = fun1(3,3)*fun1(3*3) * 3;
double unsigned_int_power(double base, int ex){
          if(ex==0){
              return 1;
          }
          if(ex ==1){
              return base;
          }

          int pre = ex>>1;
          double res = unsigned_int_power(base,pre); // 栈前面出栈元素的递归结果，即使fun1
          res = res*res; // 根据递归式得到现在的结果
          if(ex & 0x1 ==1){
              res *= base;
          }
          return res;
      }

8 二维数组  逆序遍历
bool Find(int target, vector<vector<int> > array) {
        if( array.size() ==0) return false;
        int rows = array.size();
        int cols = array[0].size();

        bool found= false;

        int row = 0;
        int column = cols-1;

        while (row < rows && column >=0 ){
            if(array[row][column] == target){
                found = true;
                return found;
            }
            else if(array[row][column] > target){
                --column;
            }else{
                ++row;
            }
        }
        return found;

    }

9 栈的递归 从尾到头打印链表
 void add_list_from_tail_to_head(ListNode* head, vector<int>& res){
        if(head == nullptr) return;

        add_list_from_tail_to_head(head->next,res);
        res.push_back(head->val);
    }

    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        add_list_from_tail_to_head(head, res);
        return res;
    }


   头脑中联想函数栈的叠加，或者把最后一次递归展开

10
   a数组 1,2,3,4
     4-1 = 3 ,3为{2，3，4} 的个数
     1+2 = 3 ，2 为{2，3} 的个数