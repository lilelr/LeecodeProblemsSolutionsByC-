1 直接用数组从0开始的下标思考问题
2 自己想的比看过往代码写得还快
3 考虑边界的问题

4 while 结合 cnt,cnt 从0 开始
  int cnt = 0;
        while (n) {
            n = (n & (n - 1));
            cnt++;
        }

5  int pre = ex>>1; 1个数除以2 乘以2， <<2

6 是不是 偶数
 if(ex & 0x1 ==奇数){
            res *= base;
        }

7 递归函数写法 写出递归式 fun(3,7) = fun1(3,3)*fun1(3*3) * 3;
double unsigned_int_power(double base, int ex){
          if(ex==0){
              return 1;
          }
          if(ex ==1){
              return base;
          }

          int pre = ex>>1;
          double res = unsigned_int_power(base,pre); // 栈前面出栈元素的递归结果，即使fun1
          res = res*res; // 根据递归式得到现在的结果
          if(ex & 0x1 ==1){
              res *= base;
          }
          return res;
      }

8 二维数组  逆序遍历
bool Find(int target, vector<vector<int> > array) {
        if( array.size() ==0) return false;
        int rows = array.size();
        int cols = array[0].size();

        bool found= false;

        int row = 0;
        int column = cols-1;

        while (row < rows && column >=0 ){
            if(array[row][column] == target){
                found = true;
                return found;
            }
            else if(array[row][column] > target){
                --column;
            }else{
                ++row;
            }
        }
        return found;

    }

9 栈的递归 从尾到头打印链表
 void add_list_from_tail_to_head(ListNode* head, vector<int>& res){
        if(head == nullptr) return;

        add_list_from_tail_to_head(head->next,res);
        res.push_back(head->val);
    }

    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        add_list_from_tail_to_head(head, res);
        return res;
    }


   头脑中联想函数栈的叠加，或者把最后一次递归展开

10
   a数组 1,2,3,4
     4-1 = 3 ,3为{2，3，4} 的个数
     1+2 = 3 ，2 为{2，3} 的个数

11
  一个指向指针的指针，用来保存中间的指针值
 void ConvertNode(TreeNode* p_node, TreeNode** p_last_node_in_list){

12 map，set 变量 tmap, tset

13          vector<int> ans(k);
         // 记得copy函数先定义目标容器的数量大小
copy(tset.begin(),tset.end(),ans.begin());

14  mulitset 标准用法
   typedef multiset<int, greater<int>> int_set;
   typedef multiset<int, greater<int>>::iterator set_iterator;
 int_set tset;
        vector<int>::const_iterator iter = input.begin();
        for(;iter!= input.end();iter++){
            if(tset.size()<k){
                tset.insert(*iter);
            }else{
                set_iterator iter_greatest = tset.begin();
                if(*iter < *(tset.begin())){
                    tset.erase(iter_greatest);
                    tset.insert(*iter);
                }
            }
        }

15 char判断是否是数字
 while (!isdigit(str[i]))
                ++i;

16 读入一行
  string str;
    while (getline(cin, str)) {

17 判断一个int 数是否溢出
                    if (((minus > 0) && (num > 0x7FFFFFFF)) || ((minus < 0) && (num > 0x80000000))) {

18 num = num*10 + str[i]-'0'
 等价于                    num = (num << 1) + (num << 3) + ((*cstr) & 0xf);


19 vecotor 排序
        sort(numbers.begin(),numbers.end());
           sort(numbers.begin(),numbers.end()，compare);  less, great
