1 直接用数组从0开始的下标思考问题
2 自己想的比看过往代码写得还快
3 考虑边界的问题

4 while 结合 cnt,cnt 从0 开始
  int cnt = 0;
        while (n) {
            n = (n & (n - 1));
            cnt++;
        }

5  int pre = ex>>1; 1个数除以2 乘以2， <<2

6 是不是 偶数
 if(ex & 0x1 ==奇数){
            res *= base;
        }

7 递归函数写法 写出递归式 fun(3,7) = fun1(3,3)*fun1(3*3) * 3;
double unsigned_int_power(double base, int ex){
          if(ex==0){
              return 1;
          }
          if(ex ==1){
              return base;
          }

          int pre = ex>>1;
          double res = unsigned_int_power(base,pre); // 栈前面出栈元素的递归结果，即使fun1
          res = res*res; // 根据递归式得到现在的结果
          if(ex & 0x1 ==1){
              res *= base;
          }
          return res;
      }

8 二维数组  逆序遍历
bool Find(int target, vector<vector<int> > array) {
        if( array.size() ==0) return false;
        int rows = array.size();
        int cols = array[0].size();

        bool found= false;

        int row = 0;
        int column = cols-1;

        while (row < rows && column >=0 ){
            if(array[row][column] == target){
                found = true;
                return found;
            }
            else if(array[row][column] > target){
                --column;
            }else{
                ++row;
            }
        }
        return found;

    }

9 栈的递归 从尾到头打印链表
 void add_list_from_tail_to_head(ListNode* head, vector<int>& res){
        if(head == nullptr) return;

        add_list_from_tail_to_head(head->next,res);
        res.push_back(head->val);
    }

    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        add_list_from_tail_to_head(head, res);
        return res;
    }


   头脑中联想函数栈的叠加，或者把最后一次递归展开

10
   a数组 1,2,3,4
     4-1 = 3 ,3为{2，3，4} 的个数
     1+2 = 3 ，2 为{2，3} 的个数

11
  一个指向指针的指针，用来保存中间的指针值
 void ConvertNode(TreeNode* p_node, TreeNode** p_last_node_in_list){

12 map，set 变量 tmap, tset

13          vector<int> ans(k);
         // 记得copy函数先定义目标容器的数量大小
copy(tset.begin(),tset.end(),ans.begin());

14  mulitset 标准用法
   typedef multiset<int, greater<int>> int_set;
   typedef multiset<int, greater<int>>::iterator set_iterator;
 int_set tset;
        vector<int>::const_iterator iter = input.begin();
        for(;iter!= input.end();iter++){
            if(tset.size()<k){
                tset.insert(*iter);
            }else{
                set_iterator iter_greatest = tset.begin();
                if(*iter < *(tset.begin())){
                    tset.erase(iter_greatest);
                    tset.insert(*iter);
                }
            }
        }

15 char判断是否是数字
 while (!isdigit(str[i]))
                ++i;

16 读入一行
  string str;
    while (getline(cin, str)) {

17 判断一个int 数是否溢出
                    if (((minus > 0) && (num > 0x7FFFFFFF)) || ((minus < 0) && (num > 0x80000000))) {

18 num = num*10 + str[i]-'0'
 等价于                    num = (num << 1) + (num << 3) + ((*cstr) & 0xf);


19 vecotor 排序
        sort(numbers.begin(),numbers.end());
           sort(numbers.begin(),numbers.end()，compare);  less, great

20 map 插入
 map<char, int> last_pos_map;
        for (int i = 0; i < len; i++) {
            if(last_pos_map.find(s[i])==last_pos_map.end()){
                last_pos_map.insert({s[i], i});
            }else{
                last_pos_map[s[i]] = i;
            }
        }

   map 查找
    int find_min_last_pos(map<char, int> &last_pos_map) {
           if (last_pos_map.empty()) return -1;
           int min_last_pos = INT_MAX;
           auto it = last_pos_map.begin();
           for (; it != last_pos_map.end(); it++) {
               min_last_pos = min(min_last_pos, it->second);
           }
           return min_last_pos;
       }


21 dfs
算法岗两道编程题，一道是八卦阵，矩阵中有八个不相连的区域，每个区域由相邻的大于零的数字组成，区域与区域之间由零隔开，求这些区域的和的最大值和最小值是多少。
 int single(int i, int j) {
           if (i < 0 || i >= m || j < 0 || j >= n || mat[i][j] == 0)
               return 0;
           int t = mat[i][j];
           mat[i][j] = 0;
           // 上下左右遍历
           for (int a = -1; a <= 1; a++)
               for (int b = -1; b <= 1; b++)
                   t += single(i + a, j + b);
           return t;
   }


22 lower_bound upper_bound 二分查找实现 log(N)
auto cmp = [](Interval a, Interval b) { return a.end + 1 < b.start; };
        auto it0 = lower_bound(intervals.begin(), intervals.end(), newInterval, cmp); >= newInterval 的第一个元素的下标
        auto it1 = upper_bound(intervals.begin(), intervals.end(), newInterval, cmp);
        > newInterval 的第一个元素的下标


23 frog_jump 403
hashmap 与 set 初始化
 unordered_map<int, set<int>> m;
        for (auto x: stones) m[x] = {};

   m[0].insert(0);
          for (int i = 0; i < n; i++) {
              for (int last_step: m[stones[i]]) {
                  for (int next_step = last_step - 1; next_step <= last_step + 1; next_step++) {
                      if (next_step > 0 && m.count(stones[i] + next_step)) {
                          m[stones[i] + next_step].insert(next_step);
                      }
                  }
              }
          }
          bool res = !m[stones[n - 1]].empty();
          return res;


 24
    #include <sstream>
        stringstream& s;
                string str;
         getline(s, str, ',');

      TreeNode* deserialize(string data) {
             if (data == "#") return NULL;
             stringstream s(data);
             return makeDeserialize(s);
         }

         TreeNode* makeDeserialize(stringstream& s) {
             string str;
             getline(s, str, ',');
             if (str == "#") {
                 return NULL;
             } else {
                 TreeNode* root = new TreeNode(stoi(str));
                 root->left = makeDeserialize(s);
                 root->right = makeDeserialize(s);
                 return root;
             }
         }


25
834. Sum of Distances in Tree
   一棵多叉树的定义和 dfs 定义下的先序和后序遍历